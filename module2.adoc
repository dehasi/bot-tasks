Файловые маски

Когда мы надеваем маску, видимой остается только часть нашего лица.

А когда мы применяем маску у строке, то действуют те же правила.

Помнишь мы копировали все книги про магических животных (zoo*).

Символ * означает любое число символов (включая 0).

Значит если у нас были книги с именами zoo, zoo1, zooABDD
они все подходят под данный шаблон.

* может стоять в любом месте: в начале, середине иди в конце.
Их может быть несколько штук. Есть и другие виды масок, но о них мы расскажем позднее.
А пока...
Давай тренироваться. Для начала посмотри на файлы, которые лежат в папке
----
$ ls
pic-chemistry1.book	pic-chemistry2.png	pic-chemistry4.book	pic-chemistry5.png	pic-magic3.jpg		zoo-magic1.book		zoo-magic4.book
pic-chemistry1.png	pic-chemistry3.book	pic-chemistry4.png	pic-magic1.jpg		pic-magic4.jpg		zoo-magic2.book		zoo-magic5.book
pic-chemistry2.book	pic-chemistry3.png	pic-chemistry5.book	pic-magic2.jpg		pic-magic5.jpg		zoo-magic3.book
----

Отлично! В нашей папке лежат какие-то книги и картинки.

Теперь давай посмотрим только на книги

----
$ ls *.book
pic-chemistry1.book	pic-chemistry3.book	pic-chemistry5.book	zoo-magic2.book		zoo-magic4.book
pic-chemistry2.book	pic-chemistry4.book	zoo-magic1.book		zoo-magic3.book		zoo-magic5.book
----

Отлично, а теперь давай посмотрим только на картинки

----
$ ls *.jpg
pic-magic1.jpg	pic-magic2.jpg	pic-magic3.jpg	pic-magic4.jpg	pic-magic5.jpg
----

Молодец, а теперь задание посложнее. Давай посмотрим только те файлы, которые имеют отношение к магии.

hint1: * может быть в любом месте и в любом количестве.
hint2: *magic*

----
$ ls
pic-chemistry1.book	pic-chemistry2.png	pic-chemistry4.book	pic-chemistry5.png	pic-magic3.jpg		zoo-magic1.book		zoo-magic4.book
pic-chemistry1.png	pic-chemistry3.book	pic-chemistry4.png	pic-magic1.jpg		pic-magic4.jpg		zoo-magic2.book		zoo-magic5.book
pic-chemistry2.book	pic-chemistry3.png	pic-chemistry5.book	pic-magic2.jpg		pic-magic5.jpg		zoo-magic3.book
----

Замечательно! 
Есть еще маска `?`, ? - означает 1 любой символ и может быть использована в любом количестве.
Т.е `??` - два любых символа и т.д.

Теперь тренируемся. В нашей папке лежат картинки в png и jpg форматах (обрати внимание на кол-во символов), давай посмотрим только на картинки.
----
$ ls *.???
pic-chemistry1.png	pic-chemistry3.png	pic-chemistry5.png	pic-magic2.jpg		pic-magic4.jpg
pic-chemistry2.png	pic-chemistry4.png	pic-magic1.jpg		pic-magic3.jpg		pic-magic5.jpg
----

Замечательно. Но и это еще не все. Мы не всегда ходим один или любое число символов.
Бывают случаи когда мы хотим конкретизировать множетво значений. Это можно сделать маской `{}`.

Например выбрать только картинки можно было и так `ls *.{png,jpg}` (внимание! пробелов быть не должно). 
Попробуй

----
$ ls *.{png,jpg}
pic-chemistry1.png	pic-chemistry3.png	pic-chemistry5.png	pic-magic2.jpg		pic-magic4.jpg
pic-chemistry2.png	pic-chemistry4.png	pic-magic1.jpg		pic-magic3.jpg		pic-magic5.jpg
----

Отлично! А теперь выбери картинки только с нечетным (1,3,5) номерами.
----
$ ls *{1,2,5}.{png,jpg}
pic-chemistry1.png	pic-chemistry2.png	pic-chemistry5.png	pic-magic1.jpg		pic-magic2.jpg		pic-magic5.jpg
----

Молодец! Но что если мы хотим выбрать картинки с номерам от 1го по 4й? Ну ок, мы можем написать `{1,2,3,4}`,
а что если 1го по 100й? Нам нужен способ указывать промежутки. И он есть! Для этого мы используем `[]`.
И можем или спиcок допустимых символов `[1234abc]` или промежутки `[1-9A-Za-z]`.

Выбери все картинки с номерами от 2го по 4й 
----
$ ls *[2-4].{png,jpg}
pic-chemistry2.png	pic-chemistry3.png	pic-chemistry4.png	pic-magic2.jpg		pic-magic3.jpg		pic-magic4.jpg
----

Отличная работа! 

Раз мы можем указывать вхождение, то хочется указывать невхождение. Например все которые не входят в промежуток `2-4`.
И это тоже можно! Для этого нам нужна маска `[!]` (восклицательный знак много где является символом отрицания и может еще встретится в такой роли).

Выбери все картинки с номерами НЕ в промежутке от 2го по 4й
----
$ ls *[!2-4].{png,jpg}
pic-chemistry1.png	pic-chemistry5.png	pic-magic1.jpg		pic-magic5.jpg
----

Отлично!

Теперь давай перейдем к другой теме. Мы знаем что есть программы которые печатают текст на экран.
Есть которые считывают текст и что-то с ним делают. 

Перед тем как мы перейдем к примерам, посмотри какие файлы есть в текущей директории

----
$ ls
----

Ну это уж было совсем просто! В папке пока ничего нет, но мы сейчас исправим. 
Но для начала тебе надо вспомнить про команду `echo` и вывести на экран фразу 'Magic! I am loving it!'

----
$ echo 'Magic! I am loving it!'
Magic! I am loving it!
----

Мы все время говорим о выводе на экран или в терминал. Но так ли это важно для программы куда выводить текст?
Программа не знает где окажется выводимый ею текст. Она просто печатает текст в поток. Теперь следи за руками.
Программа пишет что-то в поток, и то где фактически окажется текст зависит куда этот поток подключен.
Это как лить воду в трубу: заливаем с одной стороны, а литься будет туда куда подкчючен второй конец.

Ситуация с потоками такая же. Программа пишет в поток (или читает из потока), а текст появляется там, куда этот поток подключен.
По умолчанию поток подключен к терминалу, поэтому мы видим результат на экране.

А зачем так сложно? А для того чтобы мы могли перенаправлять потоки. Самый просто пример это перенапрввить что-то в файл.

Поток вывода перенаправляется оператором `>`. Попробуй перенаправить вывод echo в файл (`echo 'Magic! I am loving it!' > file`)

----
echo 'Magic! I am loving it!' > file
----

На экран ничего не вывелось, но если ты опять посмотришь содержимое папки
----
$ ls
file
----

Появился файл. Посмотри его содержимое (`cat file`)
-----
$ cat file
Magic! I am loving it!
-----

[source]
----
 _________________ 
< Отлично! >
 ----------------- 
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
----

Теперь давай научимся перенаправлять потоки ввода. Поможет нам в этом программа `cowsay`
Она текст из входного потока и печатает коровку, которая говорит этот текст (как в примере выше).

Перенаправь свой файл коровке (`cowsay < file`)

----
$ cowsay < file
 ________________________ 
< Magic! I am loving it! >
 ------------------------ 
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
----

Отличная работа! Теперь ты умеешь перенаправлять потоки. Пока только из/в файл.

Давай еще немного потренируется. Мы обновили содержимое файла. Посмотри что там (`cat file`)

----
$ cat file
Magic! I am loving it!
Nothing special :/
This is magic! O_O
Nothing special :/
Nothing special :/
This is magic! O_O
Nothing special :/
Magic! I am loving it!
Nothing special :/
Magic! I am loving it!
----

Ага! какой-то текст. Сейчас мы будем учиться искать слова в тексте с помощью программы `grep`.
GREP читает текст построчно из входного потока и пишет в выходной поток только те строчки, в которых есть искомое слово.

Перенаправить файл в поток мы уже умеем (`<`), давай поищем в файле слово `magic` (`grep magic < file`)

----
$ grep magic < file
This is magic! O_O
This is magic! O_O
----

Отлично! Видишь, регистр (большие или маленькие буквы) имеет значение. А теперь поищи слово `Magic`

----
$ grep Magic < file
Magic! I am loving it!
Magic! I am loving it!
Magic! I am loving it!
----

Молодец! Теперь ты умеешь искать в тексте. Но grep умеет намного больше чем просто искать слова.

А что если регистр нам не важен? Тогда надо запустить греп с параметром `-i` (`grep -i magic < file`).
Попробуй!

----
$ grep -i magic < file
Magic! I am loving it!
This is magic! O_O
This is magic! O_O
Magic! I am loving it!
Magic! I am loving it!
----

Замечательно! По умолчанию grep печатает строчки, где такое слово есть, но можно и наоборот. Можно попросить grep
печатать те строчки, где такого слова нет (`-v`). Давай поищем такие строки.

----
$ grep -v magic < file
Magic! I am loving it!
Nothing special :/
Nothing special :/
Nothing special :/
Nothing special :/
----

Отлично! И последний параметр на сегодня. GREP читает текст построчно, а значин он может добвлять номера строк в ответ (`-n`).
В каких строчках есть слово `special`?

----
$ grep -n special < file
2:Nothing special :/
4:Nothing special :/
5:Nothing special :/
7:Nothing special :/
9:Nothing special :/
----

Отличная работа! Параметры команд можно соделинять, точно так же как мы делали с `ls`.
Запусти grep со всеми выученными параметрами (а алфавистном порядке, что б мы смогли проверить) с найди слово `magic`
Может ты уже знаешь какой будет ответ? ;)

----
$ grep -inv magic < file
2:Nothing special :/
4:Nothing special :/
5:Nothing special :/
7:Nothing special :/
9:Nothing special :/
----

Теперь, перед тем как мы вернемся к перенаправлению потоков, мы познакомимся с еще одной прошраммой `wc` (words count)

Запусти ее и передай ей во входной поток наш файл
----
$ wc < file
      10      38     202
----

Мдя, какие-то циферки. Это число строк, слов и символов в этом тексте. Подробнее можно прочитать в `man wc`.
Нам не всегда нужно все из этого, вы можео задавать парметрами `-l` для строк `-w` для слов и  `-c` для символов.

Запусти `wc`  с нужными параметрами чтобы посчитать число слов

----
$ wc -w < file
      38
----

Хорошо. Теперь, когда мы уже знаем несколько программ работающих с текстом, мы их совместим.

Итак, для начала найди в файле строки где есть слово `special` но вывод перенаправь в файл `tmp1`
----
$ grep special < file > tmp1
----

Хорошая работа, тепеь в файле `tmp1` лежат нужные нам строки, давай найдем из количество и запишем в файл `tmp2`

----
$ wc -l < tmp1 > tmp2
----

Здорово! А теперь давай посмотрим сколько что там написано, но использовать `cat` это скучно, пусть нам
скажет об этом коровка (`cowsay`)

[source]
----
$ cowsay < tmp2
 ____
<  5 >
 ----
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
----

Неплохая работа! Мы соединили воедино три программы и получили как будто бы новую.

Но давай посмотрим на содержимое папки

----
$ ls
file	tmp1	tmp2
----

Файлы `tmp*` больше не нужны и мы их можем удалить, тем более что мы умеем пользоваться файловыми масками.
Но в идеале, лучше их вообще не создавать. Что мы делали? Мы перенаправляли вывод программы в файл, а потом
перенаправляли файл на ввод другой программы. Оказывается мы можем обойтись без файла и перенаправить вывод одной программы
на ввод другой! Делается это с помощью оператора `|` (pipe).

Давай распечатаем содержимое файла (`cat file` ) а вывод перенаправим а `wc -l`, так вы узнаем сколько же строк в файле.

----
$ cat file | wc  -l
      10
----

Отлично! А теперь задачка по сложнее, выведи содержимое в grep, возьми все строки где есть слово magic (в любом регистре)
и найди число таких строк

----
$ cat file | grep -i magic | wc -l
       5
----

Отличная работа! Посмотри какие пайлайны ты уже можешь делать. И последнее, пусть результат нам сообщит `cowsay`

----
$ cat file | grep -i magic | wc -l | cowsay
 ____
<  5 >
 ----
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
----

Теперь ты можешь компоновать несколько разных программ и трансфорсировать и фильтровать текст как тебе надо.
Для трансформации ты самостоятельно можешь ознакомиться с `tr` и `cut`. А пока на сегодня все.